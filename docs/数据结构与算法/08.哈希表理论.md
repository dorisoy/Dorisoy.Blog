---
title: 哈希表理论
date: 2021-03-30 19:15:41
tags:
  - 数据结构与算法
categories:
  - 数据结构与算法
permalink: /pages/624136/

author:
  name: dorisoy
  link: https://github.com/gezhicui
---

哈希表是一种非常重要的数据结构, 很多学习编程的人一直搞不懂哈希表到底是如何现的。

在这一章节中, 我们就一点点来实现一个自己的哈希表。通过实现来理解哈希表背后原理和它的优势。

# 哈希表

哈希表是一种非常重要的数据结构, 几乎所有的编程语言都有直接或者间接的应用这种数据结构.

## 哈希表优势

哈希表通常是基于数组进行实现的, 但是相对于数组, 它也很多的优势:

- 它可以提供非常快速的插入-删除-查找操作
- 无论多少数据, 插入和删除值需要接近常量的时间: 即 O(1)的时间级. 实际上, 只需几个机器指令即可
- 哈希表的速度比树还要快, 基本可以瞬间查找到想要的元素
- 哈希表相对于树来说编码要容易很多.

## 哈希表缺点

哈希表相对于数组的一些不足:

- 哈希表中的数据是没有顺序的, 所以不能以一种固定的方式(比如从小到大)来遍历其中的元素.
- 通常情况下, 哈希表中的 key 是不允许重复的, 不能放置相同的 key, 用于保存不同的元素.

# 哈希化

现在, 就找一种方法, 把 0 到超过 7000000000000 的范围, 压缩为从 0 到 100000。
有一种简单的方法就是使用取余操作符, 它的作用是得到一个数被另外一个数整除后余数。

取余操作的实现:

为了看到这个方法如何工作, 我们先来看一个小点的数字范围压缩到一个小点的空中。

假设把从 0~199 的数字, 比如使用`largeNumber`代表，压缩为从 0 到 9 的数字, 比如使用`smallRange`代表

下标值的结果: `index = largeNumber % smallRange`;

当一个数被 10 整除时, 余数一定在 0~9 之间;比如 13%10=3, 157%10=7。

这样就可以实现压缩，但是会出现重复的问题，重复概率为 19/20

认识情况了上面的内容, 相信你应该懂了哈希标的原理了, 我们来看看几个概念:

- 哈希化: 将大数字转化成数组范围内下标的过程, 我们就称之为哈希化。
- 哈希函数: 通常我们会将单词转成大数字, 大数字在进行哈希化的代码实现放在一个数中, 这个函数我们成为哈希函数。
- 哈希表: 最终将数据插入到的这个数组, 我们就称之为是一个哈希表

# 冲突

## 什么是冲突

如果两个数据进行哈希化后，出现了一模一样的哈希化的值，我们称为冲突。虽然我们不希望这种情况发生, 当然更希望每个下标对应一个数据项, 但是通常这是不可能的。

**举个栗子：**

就像之前 0~ 199 的数字选取 5 个放在长度为 10 的单元格中

0 如果我们随机选出来的是 33, 82, 11, 45, 90,那么最终它们的位置会是
3-2-1-5-0，没有发生冲突.

但是如果其中有一个 33,还有一个 73 呢？这样就发生了冲突。这样我们就要解决冲突

## 链地址法

链地址法是一种比较常见的解决冲突的方案.(也称为拉链法)

其实, 如果你理解了为什么产生冲突, 看到图后就可以立马理解链地址法是什么含义了.

![](https://yangblogimg.oss-cn-hangzhou.aliyuncs.com/blogImg/20220505144048.png)

从图片中我们可以看出, 链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据, 而是一个链条。

这个链条使用什么数据结构呢? 常见的是**数组**或者**链表**。

比如是链表, 也就是每个数组单元中存储着一个链表。 一旦发现重复, 将重复的元素插入到链表的首端或者末端即可。

当查询时, 先根据哈希化后的下标值找到对应的位置, 再取出链表, 依次查询找寻找的数据。

## 开放地址法

开放地址法的主要工作方式是寻找空白的单元格来添加重复的数据。
我们还是通过图片来了解开放地址法的工作方式。

![](https://yangblogimg.oss-cn-hangzhou.aliyuncs.com/blogImg/20220505144124.png)

从图片的文字中我们可以了解到, 开放地址法其实就是要寻找空白的位置来放置冲突的数据项.但是探索这个位置的方式不同, 有三种方法:

- 线性探测
- 二次探测
- 再哈希法

### 线性探测

线性探测非常好理解: 线性的查找空白的单元.

**插入 32:**

- 经过哈希化得到的 index=2, 但是在插入的时候, 发现该位置已经有了 82
- 线性探测就是从 index 位置+1 开始一点点查找合适的位置来放置 32
- 空的位置就是合适的位置, 在我们上面的例子中就是 index=3 的位置, 这个时候 32 就放在该位置.

**查询 32：**

- 查询 32 和插入 32 比较相似。首先经过哈希化得到 index=2, 比如 2 的位置结果和查询的数值是否相同, 相同那么就直接返回。不相同呢? 线性查找, 从 index 位置+1 开始查找和 32 一样的

- 这里有一个特别需要注意的地方: 如果 32 的位置我们之前没有插入, 是否将整个哈希表查询一遍来确定 32 存不存在吗?

- 当然不是, 查询过程有一个约定, 就是查询到**空位置**, 就停止. (因为查询到这里有空位置, 32 之前**不可能跳过空位置**去其他的位置.)

**删除 32：**

- 删除操作和插入查询比较类似, 但是也有一个特别**注意点**: 删除操作一个数据项时, 不可以将这个位置下标的内容设置为 null, 为什么呢?
- 因为将它设置为 null 可能会影响我们之后查询其他操作, 所以通常删除一个位置的数据项时, 我们可以将它进行特殊处理(比如设置为-1).
- 当我们之后看到-1 位置的数据项时, 就知道查询时要继续查询, 但是插入时这个位置可以放置数据.

**线性探测存在的问题**
线性探测有一个比较严重的问题, 就是**聚集** 什么是聚集呢?

比如我在没有任何数据的时候, 插入的是 22-23-24-25-26, 那么意味着下标值:2-3-4-5-6 的位置都有元素. 这种**一连串填充单元**就叫做聚集.

聚集会影响哈希表的性能, 无论是插入/查询/删除都会影响.

比如我们插入一个 32, 会发现连续的单元都不允许我们放置数据, 并且在这个过程中我们需要**探索多次**.

二次探测可以解决一部分这个问题, 我们一起来看一看.

### 二次探测

我们刚才谈到, 线性探测存在的问题: 就是如果之前的数据时连续插入的, 那么新插入的一个数据可能需要探测很长的距离.

二次探测在线性探测的基础上进行了优化:

- 二次探测主要优化的是探测时的步长, 什么意思呢?
- 线性探测, 我们可以看成是步长为 1 的探测, 比如从下标值 x 开始, 那么线性探测就是 x+1, x+2, x+3 依次探测.
- 二次探测, 对步长做了优化, 比如从下标值 x 开始, x+1², x+2², x+3².
- 这样就可以一次性探测比较常的距离, 比避免那些聚集带来的影响.

二次探测的问题:

- 但是二次探测依然存在问题, 比如我们连续插入的是 32-112-82-2-192, 那么它们依次累加的时候步长的相同的.
- 也就是这种情况下会造成步长不一的一种聚集. 还是会影响效率.

怎么根本解决这个问题呢? 让每个人的步长不一样, 一起来看看再哈希法吧.

### 再哈希法

为了消除线性探测和二次探测中无论步长+1 还是步长+平方中存在的问题, 还有一种最常用的解决方案: 再哈希法.

**再哈希法:**

- 二次探测的算法产生的探测序列步长是固定的: 1, 4, 9, 16, 依次类推.
- 现在需要一种方法: 产生一种**依赖关键字的探测序列**, 而不是每个关键字都一样.
- 那么, 不同的关键字即使映射到相同的数组下标, 也可以使用不同的探测序列.
- 再哈希法的做法就是: **把关键字用另外一个哈希函数, 再做一次哈希化, 用这次哈希的结果作为步长**.
- 对于指定的关键字, 步长在整个探测中是不变的, 不过不同的关键字使用不同的步长.

**第二次哈希化需要具备如下特点:**

- 和第一个哈希函数不同. (不要再使用上一次的哈希函数了, 不然结果还是原来的位置)
- 不能输出为 0(否则, 将没有步长. 每次探测都是原地踏步, 算法就进入了死循环)

# 三. 哈希化的效率

- 哈希表中执行插入和搜索操作可以达到 O(1)的时间级，如果没有发生冲突，只需要使一次哈希函数和数组的引用，就可以插入一个新数据项或找到一个已经存在的数据项。
- 如果发生冲突，存取时间就依赖后来的探测长度。一个单独的查找或插入时间与探测长度成正比，这里还要加上哈希函数的常量时间。
- 平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度也来越长。
- 随着填装因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重, 以我们来对比一下他们的效率, 再决定我们选取的方案.

## 装填因子

在分析效率之前, 我们先了解一个概念: 装填因子.

装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值.

> 装填因子 = 总数据项 / 哈希表长度.

开放地址法的装填因子最大是多少呢? 1, 因为它必须寻找到空白的单元才能将元素放入.
链地址法的装填因子呢? 可以大于 1, 因为拉链法可以无限的延伸下去, 只要你愿意. (当然后面效率就变低了)

在开发中，

- 线性探测、二次探测和再哈希的搜索难度随着装填因子的变大呈指数爆炸式增长。
- 而链地址法呈线性增加。链地址法相对来说效率是好于开放地址法的。所以在真实开发中, 使用链地址法的情况较多, 因为它不会因为添加了某元素后性能急剧下降.

下一篇文章，我们来撸一个哈希表的实现
